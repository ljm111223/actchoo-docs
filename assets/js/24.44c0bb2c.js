(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{507:function(t,s,a){"use strict";a.r(s);var r=a(4),v=Object(r.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"垃圾回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收"}},[t._v("#")]),t._v(" 垃圾回收")]),t._v(" "),a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#常用变量标记策略"}},[t._v("常用变量标记策略")]),a("ul",[a("li",[a("a",{attrs:{href:"#标记清理"}},[t._v("标记清理")])]),a("li",[a("a",{attrs:{href:"#引用计数"}},[t._v("引用计数")])])])])])]),a("p"),t._v(" "),a("p",[t._v("[toc]")]),t._v(" "),a("p",[t._v("JavaScript 是使用垃圾回收的语言，也就是说"),a("strong",[t._v("执行环境负责在代码执行时管理内存")]),t._v("。")]),t._v(" "),a("p",[t._v("基本思路很简单："),a("strong",[t._v("确定哪个变量不会再使用，然后释放它的内存")]),t._v("。这个过程是"),a("strong",[t._v("周期性")]),t._v("的，即垃圾回收程序每隔一段时间（或者说在代码执行过程中某个预定的收集时间）就会自动运行。")]),t._v(" "),a("p",[t._v("垃圾回收过程是一个近似且不完美的方案，因为某块内存是否还有用，属于“"),a("strong",[t._v("不可判定的")]),t._v("”问题，意味着靠算法是无法解决的。")]),t._v(" "),a("h2",{attrs:{id:"常用变量标记策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常用变量标记策略"}},[t._v("#")]),t._v(" 常用变量标记策略")]),t._v(" "),a("p",[t._v("垃圾回收程序必须跟踪记录哪个变量还会使用，以及哪个变量不会再使用，以便回收内存。如何标记未使用的变量也许有不同的实现方式，但在浏览器的发展历史上，用到过两种主要的标记策略："),a("strong",[t._v("标记清理")]),t._v("和"),a("strong",[t._v("引用计数")]),t._v("。")]),t._v(" "),a("h3",{attrs:{id:"标记清理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#标记清理"}},[t._v("#")]),t._v(" 标记清理")]),t._v(" "),a("p",[a("strong",[t._v("JavaScript 最常用的垃圾回收策略是标记清理")]),t._v("（mark-and-sweep）。")]),t._v(" "),a("p",[t._v("在变量"),a("strong",[t._v("进入上下文")]),t._v("（比如在函数内部声明一个变量时），变量会被"),a("strong",[t._v("加上存在于上下文中的标记")]),t._v("。而不在上下文中的变量（全局变量），逻辑上讲，永远不应该释放它们的内存。")]),t._v(" "),a("h4",{attrs:{id:"变量加标记方式-不重要"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#变量加标记方式-不重要"}},[t._v("#")]),t._v(" 变量加标记方式(不重要)")]),t._v(" "),a("ol",[a("li",[t._v("变量进入上下文时，反转某一位")]),t._v(" "),a("li",[t._v("维护“在上下文中”和“不在上下文中”两个列表，进行对应的变量转移")])]),t._v(" "),a("h4",{attrs:{id:"标记清理策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#标记清理策略"}},[t._v("#")]),t._v(" 标记清理策略")]),t._v(" "),a("ol",[a("li",[t._v("垃圾回收程序运行的时候，会"),a("strong",[t._v("标记内存中存储的所有变量")])]),t._v(" "),a("li",[t._v("将"),a("strong",[t._v("所有在上下文中的变量")]),t._v("以及"),a("strong",[t._v("被在上下文中的变量引用的变量")]),t._v("的"),a("strong",[t._v("标记去掉")]),t._v("，剩下还有标记的就是待删除的变量，因为在任何上下文中的变量都不会访问他们")]),t._v(" "),a("li",[t._v("垃圾回收程序再做一次"),a("strong",[t._v("内存清理")]),t._v("，"),a("strong",[t._v("销毁带标记的所有值")]),t._v("并回收他们的内存")])]),t._v(" "),a("h3",{attrs:{id:"引用计数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#引用计数"}},[t._v("#")]),t._v(" 引用计数")]),t._v(" "),a("p",[a("strong",[t._v("引用计数的思路是对每个值都记录它被引用的次数")]),t._v("，当一个值的引用数为 0 时，就说明没法再访问到这个值了，因此就可以安全地收回内存了。")]),t._v(" "),a("h4",{attrs:{id:"严重问题-循环引用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#严重问题-循环引用"}},[t._v("#")]),t._v(" 严重问题：循环引用")]),t._v(" "),a("p",[t._v("循环引用，就是对象 A 有一个指针指向了对象 B，而同时对象 B 也有一个指针指向了对象 A。")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("problem")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" objectA "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" objectB "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    \n    objectA"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("someOtherObject "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" objectB\n    objectB"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("anotherObject "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" objectA\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("这里 "),a("code",[t._v("objectA")]),t._v(" 和 "),a("code",[t._v("objectB")]),t._v(" 通过各自属性的互相引用，引用数都为 2，但在函数结束后，二者都不在作用域中，而在引用计数策略下，二者占用的内存都不会释放。")]),t._v(" "),a("h5",{attrs:{id:"解决方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决方法"}},[t._v("#")]),t._v(" 解决方法")]),t._v(" "),a("p",[t._v("在 IE8 及更早的版本中，BOM 和 DOM 不是 JS 的原生对象，而是组件对象模型 COM（Component Object Model），其使用引用计数实现垃圾回收。")]),t._v(" "),a("p",[t._v("为避免类似的循环引用问题，应该确保不使用的情况下切断原生 JavaScript 对象与 DOM 元素之间的连接，如：把变量设置为 "),a("code",[t._v("null")]),t._v(" 实际上会切断变量与之前引用值之间的关系。")])])}),[],!1,null,null,null);s.default=v.exports}}]);